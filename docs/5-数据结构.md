# 小橙编程学习宝典  
> [!tip]
> ***XiaoCheng Programming Learning Book***
>

## 一、线性结构（线性表）

💬 描述： 除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且只有一个直接后继。

- 顺序存储：顺序表
- 链式存储：链表

⭐线性枚举、前缀和、双指针、二分枚举、三分枚举、离散化

### 1. 顺序表

用**一组地址连续的存储单元**依次存储线性表的数据元素  
数组：列表的实现方式之一（**索引**）  
二维数组

时间复杂度：

- 读取元素：O(1) ===== 内存地址 + 索引
- 查找元素：O(n)
- 插入元素：O(n) ===== 末尾插入为O(1) 中间插入(频繁)：链表更佳
- 删除元素：O(n)

### 2. 字符串

KMP、字典树、马拉车、AC自动机、后缀数组、BM

1. 比较字符串： == | equals | compareTo  

    ```Java
    // 定义 s1、s2、s3
    String s1 = "Hello World!";
    String s2 = s1;                 // 将 s1 的引用值赋给了 s2, 指向同一个对象
    String s3 = new String(s1);     // 重新创建了一个对象，在内存中地址不同，值内容相同

    // ① 使用 "==" 比较 (内存地址，是否指向同一对象)
    s1 == "Hello World";        // true
    s1 == s2;                   // true
    s1 == s3;                   // false⭐

    // ② 使用 "equals()" 方法比较 (仅比较值)
    s1.equals("Hello World");   // true
    s1.equals(s2);              // true
    s1.equals(s3);              // true

    // ③ 使用 "CompareTo()" 比较（两个字符串的字典顺序）
    s1.compareTo("Hello World") == 0);  // true
    s1.compareTo(s2) == 0);             // true
    s1.compareTo(s3) == 0);             // true
    ```

    总结：
    - ① "=="比较 **字符串** 比较的是其内存的地址值，  
    对于**基本数据类型**(int,char) 比较值是否相等。  
    - ② "equals()"比较，在Object类中  <u>默认也比较的是内存地址</u>，  
    但在许多类(String、Integer、Date)中重写了，只用来比较 值是否相同。  
    - ③ "CompareTo"比较 是字符串的字典顺序，相同为0，  
    a.CompareTo(b),若a在b前，返回负值，反之返回正值。
    - ④ **str1.equlasIgnoreCase(str3)** 不考虑大小写  

2. 连接字符串  
    使用 **toCharArray** 转换为字符数组，字符串可变  
    如果经常连接字符串，使用 **StringBuilder** 数据类型  
    str1.concat(str2);
3. 查找字符串  
    .indexOf("a"); 首次出现的索引
    .lastIndexOf("a"); 最后一次出现的索引
4. 获取指定位置的字符串  
    .charAt(3);
5. 其他  
   - .substring(2,4) 截取子串
   - .startWith("ab", 1) 判断字符串的开始与结尾(end)
   - .parseInt(s); .parseLong(s);
   - .valueOf(s).intValue(); 转换
   - .split(" ", 2) 分成两份
6. 字符数组、byte数组、字符串
   - char mychar[] = s.toCharArray();
   - byte[] Str2 = s.getBytes();
7. StringBuffer
   - .append
   - .delete(0, 1) 删除下标 0到1
   - .deleteCharAt(str, length()-1) 删除最后一个字符
   - .reverse() 反转字符串
   - .insert(1,2) 在索引为1的位置插入一个 字符型的 2
   - .setLength(4) 设置字符串长度
   - .capacity() 获取当前容量

### 3. 链表

#### (1) 单向链表

一组任意的存储单元，可连续可不连续  
**结点**：包括 数据域 / 指针域  
> 头指针L ---> 头结点(不存数据) ---> 首元结点

顺序表和链表的区别：  

   1. 空间性能
    - **存储空间分配**： 顺序表要预先分配空间还有个数限制，链表没有
    - **存储密度**： 链表要设置额外的指针域，存储密度低 <1，顺序表密度=1
   2. 时间性能
    - **存取元素效率**：顺序表是 随机存取 效率高，链表是顺序存取，取值一般用顺序表（R）
    - **插入和删除元素效率**：频繁插入或删除适宜用链表（I、D）

#### (2) 双向链表

既可以从头又可以从末尾开始遍历  
![alt text](images/双向链表.png)  
左指针 指向上一个结点的 数据  
右指针 指向下一个结点的 数据

#### (3) 循环链表

![alt text](images/循环链表.png)  
尾结点的指针指向了 **头结点**(没有数据的)  
特点：  

- 可以从任意结点出发，访问到链表的全部结点
- 带有头结点的循环链表，为空链表时，头结点的指针域指向自己
- 带有头结点的循环链表，为非空链表时，终端结点指针域指向头结点

插入：  
在 cur和cur->next 结点中间插入  
第一步：将插入结点的指针指向 cur->next 结点的data  
第二步：将 cur 结点的指针指向插入节点的data  
⭐循序一变，就找不到cur->next了

删除：  
直接找到要删除结点n的前一个结点，让其指向下一个结点的下一个结点

### 4. 栈（后进先出）

#### (1) 顺序栈

只允许在一段插入或删除的线性表  
<img src="images/栈.png" width="250">  

#### (2) 链栈

![链栈](images/链栈.png)  
栈空：头指针指向Null  

#### (3) 共享栈（两栈共享空间）

![共享栈](images/共享栈.png)  
栈空：两栈都向两边收缩，左栈top=-1，右栈top=MaxSize  
栈满：两栈都向中间挤压，当top0 + 1 = top1，相遇

### 5. 队列

#### (1) 顺序队列（先进先出FIFO）

需要队头指针（front）和队尾指针（rear）  
假溢出：  
再在E的上方插入元素F，会超过队列最大长度，但并未全部占慢  
![假溢出](images/假溢出.png)  

#### (2) 循环队列（解决假溢出）

头尾相接：  
<img src="images/循环队列.png" width="400">  

为判断 循环对列为空或满，要牺牲一个存储空间  

- 队满（Q.rear+1）%MAXSIZE==Q.front； front在rear的下一位置
- 队空 Q.rear==Q.front；在同一位置

#### (3) 双端队列

两端都进行入队和出队

#### (4) 链队列

将队头指针指向链队列的头结点，而队尾指针指向终端结点  
![alt text](images/链队列.png)  

队列空：front==rear

---

## 二、散列结构

💬 描述：一种为保证增删效率和查询效效率的数据结构（数组+链表）  

1. 散列表（Hash表）：散列中的数组
2. 散列函数（Hash函数）：用来计算一个元素应该存放在Hash表中哪个位置（取余法/模地址法）
3. Hash碰撞/冲突： 两个数据计算出再hash表中位置相同
4. Hash桶：为解决hash碰撞产生了hash桶，一个hash桶中存储了所有发生hash碰撞的元素，链表就是hash桶的一种实现方式（链地址法，拉链法）

哈希冲突解决方法：  

   1. 开放定制法（线性探测再散列、平方探测再散列、双探测再散列）
   2. 链地址法
   3. 公共溢出区法
   4. 再散列法

Hash表的删除：  
&emsp;&emsp;链地址法可直接删除元素，开发地址法不行，应该删除后放入一个不存在的数据（-1）

---

## 三、集合与映射

### 1. 集合

💬 描述：具有某种特性的事物的整体，一种不允许值重复的顺序数据结构  
特性： 无序性、互异性、确定性

### 2. 映射

💬 描述：集合与集合之间的一种对应关系，用来存储键值对  
**映射的实现通常使用哈希函数来快速定位键对应的值**

特点：键唯一性、灵活的键类型  
映射的应用场景：

- 数据库索引： 数据库查询中常使用映射来加速查找操作。
- 缓存管理： 映射可以用于缓存管理，加快对热门数据的访问。
- 配置存储： 映射可以用于存储配置项和参数。

映射的优势：

- 快速查找： 映射通过键快速查找对应的值，具有高效的查找速度。
- 数据关联性： 映射可以用于存储具有关联关系的数据。

### 3. 位图 (BitMap)

💬 描述：用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况，用来判断某个数据存不存在。  

用数组实现，0表示存在，1表示不存在  

是一种 **直接定址法** 的哈希

---

## 四、树

### 1. 二叉树

每个节点最多两个子树，可为空集(左右节点)

- 性质1：二叉树第i层上的节点数目最多为 2^{i-1} (i≥1)
- 性质2：深度为k的二叉树至多有2^k-1个节点（k>=1）
- 性质3：包含n个节点的二叉树的高度至少为log2 (n+1)
- 性质4：在任意一颗二叉树中，若终端节点的个数为n0,度为2的节点数为n2，则n0=n2+1  

<img src="images/二叉树.png" width="350" height="200">

分类：

- 满二叉树
- 完全二叉树 （最下层节点可小于2，节点全靠左）
- 二叉搜索树 （左小右大）
- ⭐平衡二叉搜索树(AVL) ：（左右子树高度差绝对值不超过1）

链式存储(左右指针)、顺序存储(数组存储)  
**深度优先**：前序遍历、中序遍历、后序遍历  
**广度优先**：层次遍历(迭代法)  

### 2. 字典树（前缀树）

3个基本性质：  

- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符都不相同。

<img src="images/前缀树.png" width="400">

### 3. 堆(Heap)

堆是一棵完全二叉树，某个节点的值不大于或不小于其父节点的值

小顶堆：父节点比子节点值小  
大顶堆：父节点比子节点值大

堆的插入：  
先挂在到树的子节点尾部，判断大小，逐层交换  
堆的删除：  
取出最后一个元素放到以及被删除的顶部位置，再判断大小进行交换

### 4. 线段树

用于维护区间信息(必须满足结合律), 可以实现O(log n)的区间修改,还同时支持多种操作  

线段树是一棵 **平衡二叉树** 。母结点代表整个区间的和，越往下区间越小,每个节点都对应一条线段[ 区间 ],但并非所有线段都是树的节点  
对于一个数组 [1,2,3,4,5]  
<img src="images/线段树.png" width="400">

采用深度优先DFS构建线段树

### 5. 哈夫曼树 (最优树)

又称:带权路径长度最短的二叉树  
给定N个权值作为N个叶子结点，构造一棵二叉树，该树的带权路径长度达到最小 (带权路径长度最短的树,权值较大的结点离根较近)

<img src="images/哈夫曼树.png" width="400">

- 哈夫曼编码  
   一种压缩编码的编码算法,对频率高的字符使用较短的编码,频率低的字符使用较高的编码,实现数据压缩  
   <img src="images/哈夫曼编码.png" width="200">

### 扩展

#### 1. 红黑树

(1) 一种 **自平衡** 的二叉树,高效的查找树,可以在O(logN)的时间内完成查找/增加/删除等操作  

(2) 避免普通二叉树在极端情况变成链表,采用自平衡的查找树(AVL树/红黑树)  
(3) 红黑树性质:  

- 节点是红色或黑色。
- 根是黑色。
- 所有叶子都是黑色（叶子是NIL节点）。
- 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
- 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）

还要考虑 某个节点到其每个叶子节点路径长度的问题,路径过长效率降低  
所以,在路径最长的情况下,红色节点数 = 黑色节点数  
该路径长度 = 2 * 黑色节点数(最短路径的两倍)

(4) 颜色变化和旋转(可以保证树的大致平衡,最多3次旋转实现平衡)  

- LL( / )型 =======> 先变色再右旋

   <img src="images/红黑树LL.png" width="400">

- LR( < )型 =======> 左旋变成LL型,变色+右旋

   <img src="images/红黑树LR.png" width="500">

- RR( \ )型 =======> 先变色再左旋
- RL( > )型 =======> 右旋旋变成RR型,变色+左旋

(5) 插入  
&emsp;&emsp;新插入的节点应该是红色,若是黑色则该节点所在路径比其他路径多出一个黑色节点,比较麻烦 (插入的根节点除外)  

1. N 的父节点是红色，叔叔节点 U 也是红色。由于 P 和 N 均为红色，需要调整。P 和 U 的颜色染成黑色，再将 G 的颜色染成红色,其上要变成红色节点,向上递归调整  

   <img src="images/红黑树插入3.png" width="400">
2. N 的父节点为红色，叔叔节点U为黑色,节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。对P左旋，调整N与P的位置，变成上一种情况  

   ![alt text](images/红黑树插入4.png)
3. 第2种还可以对G右旋，调整P与G的位置，互换颜色  
   ![alt text](images/红黑树插入5.png)

(6) 删除  
&emsp;&emsp;要首先确定删除的节点有几个孩子节点，若有2个就不能直接删除，要先找到该节点先驱（左子树中最大的节点）或者后继（右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。  
&emsp;&emsp;当删除的红色时，拿子节点补空位即可；当为黑色时，那所有经过该节点路径黑高都-1，若该节点子节点时红色，拿子节点替换被删除的节点，并将子节点染成黑色。若子节点为黑色较复杂：  

1. S 为红色，其他节点为黑色，此时可对N的父节点左旋，然后互换P与S颜色，黑高不满足，继续调整
![alt text](images/红黑树删除2.png)
2. N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色，此时可简单把S染成红色  
![alt text](images/红黑树删除3.png)
3. N 的父节点是红色，S 和 S 孩子为黑色,交换P与S颜色即可。
4. S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。对 S 进行右旋操作，并互换 S 和 SL 的颜色。
5. S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色  
<img src="images/红黑树删除456.png" width="400">

#### 2. 伸展树（基于程序局部性原理）

在每次一个节点被访问后，就把它推到树根的位置（特殊的旋转）  
**伸展**：  
如果查询节点的父节点不是根节点，那么该节点一定有祖父节点  

- 之字形
   总是先旋转查询节点，先左再右  
   <img src="images/之字形.png" width="500">
- 一字型
   先旋转其父节点到祖父节点，然后再旋转查询节点到父节点  
   <img src="images/一字形.png" width="500">

#### 3. Treap（树堆 Tree+Heap）

一个**随机附加域**满足堆的性质的二叉搜索树  
在调整（插入、删除元素）后维护堆的性质只用左旋右旋

#### 4. B+树

1. **B树** (B-树、多路平衡查找树)  
   m阶的B树满足：  

   - 每个结点最多有m棵子树。
   - 具有k个子树的非叶结点包含k -1个键。
   - 每个非叶子结点（除了根）具有至少⌈ m/2⌉子树，即最少有⌈ m/2⌉-1个关键字。
   - 如果根不是终端结点，则根结点至少有一个关键字，即至少有2棵子树。【根的关键字取值范围是[1，m-1]，子树的取值范围是[2,m]】
   - 所有叶子结点都出现在同一水平，没有任何信息（高度一致）。
   - 最小高度：h < logm(n+1)  
      <img src="images/B树.png" width="500">

2. B+树

   MySQL的InnoDB引擎使用B+树来作为索引和数据的存储结构，优化在于：  
   B+树的所有数据都存储在叶子节点，非叶子节点只存储索引  
   叶子节点的数据使用双向链表的方式进行关联  

   - 每个结点最多有m棵子树。
   - 如果根不是终端结点，则根结点至少有一个关键字，即至少有2棵子树。【根的关键字取值范围是[1，m-1]】
   - 每个关键字对应一棵子树（与B树的不同），具有k个子树的非叶结点包含k 个键。
   - 每个非叶子结点（除了根）具有至少⌈ m/2⌉子树，即最少有⌈m/2⌉个关键字。
   - 终端结点包含全部关键字及相应记录的指针，叶结点中将关键字按大小顺序排序，并且相邻叶结点按大小顺序相互链接起来。
   - 所有分支结点（可以视为索引的索引）中金包含他的各个子节点（即下一级的索引块）中关键字最大值，及指向其子结点的指针。  
   <img src="images/B+树.png" width="450">

3. B树和B+树的区别

   |-------|B树|B+树|
   |:-----|:--------:|:--------:|
   |关键字|(m/2)-1到m-1|m/2到m|
   |子树|非叶根：2 - m;<br>其他：m/2 - m |非叶根：2 - m;<br>其他：m/2 - m|
   |key-subtree|k个key有k+1棵树|k个key有k棵树|
   |非终端节点|包含有用信息|只是索引|
   |终端节点|不会出现非终端节点的key|会出现非终端节点的key|

#### 5. 左偏树

属于可并堆，支持快速合并，是优先队列的一种实现方式  
**外界点**：左节点或右节点为空  
一个n个节点的二叉树，根节点的dist外界点不超过log(n+1)  
每个节点左儿子dist大于等于右儿子dist  
每个节点的dist都等于其右儿子的dist + 1  

**合并：**  
依据堆的合并进行合并；若合并后左二子的dist小于右儿子的dist，则交换两棵子树  
时间复杂度：O(logN + logM)  

**删除**： 直接合并左右儿子

#### 6. 树链剖分

树链剖分是根据轻重儿子，将一棵树剖成多条链  

**重儿子**：一个结点的所有子树中，结点数最多的子树的根节点
得到 **重链**

维护链：

- dfs序：要维护的是重链，搜重儿子，将它转换到数列上来，不先搜重儿子，重链上的dfs序可能会断掉（深度优先）   
<img src="images/树链剖分.png" width="300">

时间戳：dfs第一次访问到达每个节点的时间，从1开始叠加  
用处：把树变成连续的，某节点的子树上的节点一定大于这个节点的时间戳且连续

---

## 五、图

### 1. 最短路径

- 迪杰斯特拉算法(贪心算法)

使用 **广度优先搜索** 解决赋权有向图或者无向图的单源最短路径问题  
<img src="images/迪杰斯特拉1.png" width="400">
<img src="images/迪杰斯特拉2.png" width="400">
<img src="images/迪杰斯特拉3.png" width="400">

- 弗洛伊德算法（Floyd）

使用两个二维矩阵，画十字，每次更新值后取对角线下一元素：  
十字中以及其中无穷值对应的行和列不用更新，剩下的相加值更小才更新

```Txt
1. 矩阵D记录顶点间的最小路径  
例如D[0][3] = 10，说明顶点 0 到 3 的最短路径为10；

1. 矩阵S记录顶点间最小路径中的中转点
例如S[0][3] = 1 说明 0 到 3的最短路径轨迹为：0 -> 1 -> 3。
```


<img src="images/佛洛依德1.png" width="400">
<img src="images/佛洛依德2.png" width="400">

### 2. 并查集

支持两种操作：  

- 合并（Union）：把两个不相交的集合合并为一个集合。
- 查询（Find）：查询两个元素是否在同一个集合中。

类比成帮派，代表元素位帮主,有事找帮主(根节点)  
<img src="images/并查集.png" width="150">  

**路径压缩**： 变成一个链效率较低，使 **每个结点的父节点都设成根节点**  
**按秩合并**： 让秩小的树依附到秩大的树上  

秩(rank): 子节点个数

### 3. 最小生成树

有n个顶点的无向完全图最多包含 n的(n-2)次方颗生成树  

Kruskal克鲁斯卡尔算法： （贪心算法）  
先分开，再合并  
先将所有 **边** 按照权值非降序排列，选择权值最小的边，无环形成则一直连接，直到连接全部节点或n-1条边

Prim普利姆算法：  （贪心算法）  
起点出发，每次寻找权值最小的点加入 **整体**，再看连接这个整体的节点权值最小，加入。

### 4. 拓扑排序

一个 **有向无环图DAG** 的所有顶点的线性序列  
满足：  

- 每个顶点出现且只出现一次。
- 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

常用方法：  
选一个没有前驱(入度为0)的顶点输出并删掉其和其边，重复  
<img src="images/拓扑排序.png" width="400">

### 扩展

#### 1. 最近公共祖先（LCA）

- 基础法：进行一趟dfs，求出每个点的深度，先让两节点深度相等，再一起向上爬，直到两点相遇，此点为LCA
- 倍增算法：往上爬变成了“跳”，例如a与b相差22，变成16、4、2个单位即可

#### 2. 强连通分量

有向图G中，如果两个顶点u，ｖ间有一条从ｕ到ｖ的有向路径，同时还有一条从ｖ到ｕ的有向路径，则称 **两个顶点强连通**。如果有向图G的每两个顶点都强连通，称G是一个 **强连通图**。有向非强连通图的极大强连通子图，称为 **强连通分量**。  

DFS生成树  
![alt text](images/DFS生成树.png)  
4种边：

1. 树边： 每次搜索找到一个还没有访问过的结点的时候就形成了一条树边  
2. 返祖边：（7--->1）指向祖先节点的边
3. 横叉边：（9--->7）搜索时遇到一个已经访问过的结点，并非是当前节点的祖先
4. 前向边：（3--->6）搜索时遇到子树中的结点

Tarjan 算法求强连通分量：  

- 时间戳（dfs[]）: 每个点第一次被访问的时间的顺序
- 追溯值（low[]）: 点x的追溯值为其子树满足以下条件的最小时间戳
  - 该点已经访问过[ 有dfn值 ]
  - 存在一条从x出发的边以它为终点

<img src="images/Tarjan算法.png" width="400">  
① 从1遍历到5时，如果选择先走5 -> 2，那么点2、3、4、5的low值都会追溯到2的时间戳  
② 点5继续遍历，会到点1并发现1也走过了并且dfn[ 1 ]的时间戳更早  
③ 最后这个图被分为了三个强连通分量（12345、7、689）

#### 3. 双连通分量

无向图中2种双连通分量：  
1.边联通分量，e-DCC  
2.点联通分量，v-DCC  

概念：  

- 桥：删除此无向边后，图变的不连通
- 边双连通分量：极大的不含有桥的连通区域，说明无论删除e-DCC中的哪条边，e-DCC依旧连通
- 割点：删除该点（与该点相关的边）后，图变得不连通
- 点双连通分量：极大的不含有割点的连通区域

#### 4. 二分图（偶图）

设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)  
<img src="images/二分图.png" width="500">  

- 匹配：G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点  
- 极大匹配：在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数  
- 最大匹配：所有极大匹配当中边数最大的一个匹配  
- 完全匹配：一个匹配中，图中的每个顶点都和图中某条边相关联  

求二分图匹配可以用最大流、匈牙利算法

- 交替路：从一个未匹配的点出发，依次经过未匹配边、匹配边、未匹配边.  
- 增广路：从一个未匹配的点出发，走交替路，到达了一个未匹配过的点  

#### 5. 2-sat

#### 6. 欧拉回路

#### 7. 哈米尔顿回路

#### 8. 迭代加深

#### 9. A*

#### 10. 稳定婚姻

#### 11. 双向广索

#### 12. 差分约束

#### 13. 跳跃表

#### 14. 树状数组

#### 15. 最大流

---

## 六、算法

### 1. 排序

- ①冒泡排序  
   比较相邻的元素，交换，重复多轮  
- ②快速排序  
   指定一个base(一般为第一个数)，定义左右指针(l,r)，右指针r->左寻比base小的数并与l交换，  
   再左指针l->右寻大于base的数并与r交换，直至l与r指向同一个数，再替换为base，第一轮结束
- ③插入排序  
   构建有序序列，对于未排序序列，在已排序中从后向前扫描，在合适位置插入
- ④希尔排序(缩小增量法)  
   分组思想，取gap=5值分5组，在每组中进行直接插入排序，并每次减小gap值。  

   ![alt text](images/希尔排序.png)
- ⑤选择排序  
   在未排序中找最小，放到起始位置，再在剩余未排序中找最小拍到已排序的末尾
- ⑥堆排序
   堆(近似完全二叉树)  
   》子节点的键值总小于或大于父节点  
   》大根堆：升序 ======= 小根堆：降序  
   基本思想:
   > 将待排序的数组构造大根堆，顶端即为最大值  
   > 与末尾的数交换  
   > 再将剩余的n-1个数再构造成大根堆，并与末尾的交换。

- ⑦归并排序  
   将未排序序列从中间分为2部分，再分为4部分，直至为一个一个的数据，再两两归并，并排序

- ⑧计数排序  
   先找到无序数组的最大值与最小值，并申请额外空间（max-min+1）  
   按照无序数组的数值与额外空间的下标一致，每次+1

- ⑨桶排序(计数排序pro)  
   确定数组元素分布范围，分出n个桶，区间依次为[0-9]、[10-19]等  
   将元素放入桶中并进行排序，最后依次输出

- ⑩基数排序  
   准备10个桶(0-9)，按照数组中元素 个位 的值，入桶并排序

---

### 2. 贪心

选取局部最优解

### 3. 分治

分治思想，分而治之  
用于二分搜索、合并排序、快速排序、汉诺塔

### 4. 动态规划

### 5. 扩展

#### 1. 递归

拆分子问题，记住过往，减少重复计算。  
1+1+1+1=4  左边加一个1+ 变成5  
记住求过的解来节省时间
<=>经典问题：青蛙跳台阶  

```js
f（10） = f（9）+f(8)
f (9)  = f(8) + f(7)
f (8)  = f(7) + f(6)
...
f(3) = f(2) + f(1)

// 即通用公式为: f(n) = f(n-1) + f(n-2)
```

递归耗时，存在大量重复计算，使用动态规划(带备忘录)  
一般使用一个数组或者一个哈希map充当这个备忘录

```Java
//先判断有没计算过，即看看备忘录有没有
if (tempMap.containsKey(n)) {
    //备忘录有，即计算过，直接返回
    return tempMap.get(n);
} else {
    // 备忘录没有，没有计算过，执行递归计算,并把结果保存到备忘录map中，对1000000007取余（题目规定）
    tempMap.put(n, (numWays(n - 1) + numWays(n - 2)) % 1000000007);
    return tempMap.get(n);
}
```

#### 2. 回溯

从一条路往前走，能进则进，不能进则退回来，换一条路再试，从而搜索到抵达特定终点的一条或者多条特定路径。

#### 3. 枚举

#### 4. DP

##### (1) 线性DP

##### (2) 树形DP

##### (3) 区间DP

##### (4) 数位DP

##### (5) 状压DP

#### 5. 记忆化搜索

#### 6. 背包问题

#### 7. 查找

##### (1) 顺序查找

从数组的头部开始顺序查找，如果找到目标元素，就返回目标元素的位置，如果没有找到，返回 -1.

##### (2) 二分查找

该数组元素 **有序**,每次分两半，左小右大，如果在数组内找到元素，返回元素的位置，否则返回 -1

##### (3) 分块(索引顺序)查找

额外建立一个“索引表”，将查找表分为若干子表（或称块），对每个子表建立一个索引项，其中包含两项内容：关键字项（其值为该子表内的最大）和指针项（指示该子表的第一个记录在表中的位置）。每个索引项构成一个索引表，索引表按关键字有序排列。  
![alt text](images/分块查找.png)

##### (4) 树结构查找

二叉树查找，左子树小，右子树大

##### (5) 散列表查找

使用哈希函数，和开放地址法等查找

#### 8. 字符串匹配

##### (1) KMP

核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的  
时间复杂度是 O(m+n)  
![alt text](images/KMP.png)  
字符串P有字串 `ACT` 和 `ACY`，当T与Y不匹配时，可能匹配左边的AC，就从j的位置开始比较  

构造next数组，存储，P字符串的 最长公共前缀后缀长度，且next[0]=-1

发现两个字符不匹配，立即移动到 next数组下表的位置

##### (2) 算法-前缀树（Trie树）

根节点不包含字符，将根节点到某一结点路径上经过的字符连接起来就是对应的字符串
