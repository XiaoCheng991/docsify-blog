# 小橙编程学习宝典  
>
> ***XiaoCheng Programming Learning Book***
>

## 经典算法题集锦

### 数组和字符串

#### 一、数组

1. 寻找数组的中心索引

    ```Java
    public int pivotIndex(int[] nums) {
      int presum = 0;
      //前缀和
      for (int x : nums) {
         presum += x;
      }      
    
      int leftsum = 0;
      for (int i = 0; i < nums.length; ++i) {
          //根据  2 * 左 + 中 = 前缀和
          if (2*leftsum + nums[i]== presum){
              return i;
          }
          // 左边逐步增加
          leftsum += nums[i];          
      }
      return -1;}
    ```

    **总结：**  

    找规律，中心索引符合：（ 左 + 中 + 右 = All） 且 左 = 右  
    只需计算（ 左 和 All ）即可获得 中

    ---

2. 搜索插入位置(二分查找法) ====> 已排好序的  
&emsp;&emsp;给1个排序数组和个1目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。  
&emsp;&emsp;⭐️必须使用时间复杂度为 O(log n) 的算法。  
![算法示例1](images/算法示例1.png)

    ```Java
    1. 暴力解法：   不满足时间复杂度为O(log n)  此乃线性搜索
    public int searchInsert(int[] nums, int target) {
        // 从左往右比较，若目标数更小，则返回此位置的下标 i
        for (int i = 0; i < nums.length; i++){
            if (target <= nums[i]) return i;
        }
        // 若目标树最大，拍到最后，则返回数组长度，相当于最后一位下标 +1
        return nums.length;    }

    2. 正经解法  二分查找法
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            // 计算中间值
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        // 如果循环结束仍然没有找到目标值，那么返回left的位置，即应该插入的位置
        return left;    }
    ```

    **总结：**  
    利用二分查找法，计算mid值，mid小则把范围定在右，重新计算mid

    ---

3. 合并区间  
&emsp;&emsp;以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

    ```Java
    public int[][] merge(int[][] intervals) {
        // 边缘判断
        if (intervals.length <= 1) return intervals;

        // 对原先数组排序
        Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));

        // 创建一个列表用于存储合并后的数据
        List<int[]> res = new ArrayList<>();

        res.add(intervals[0]);
        int last = 0;

        for (int i = 0; i < intervals.length; ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            // 右 1 < 左 2 直接加
            if (res.size() == 0 || res.get(res.size() - 1)[1] < L) {
                res.add(new int[]{L, R});
            } 
            // 右 1 >= 左 2 需要合并
            else {
                // 排序完 左 1最小 固定，取（右1，右2）最大
                res.get(res.size()-1)[1] = Math.max(res.get(res.size()-1)[1],R);
            }
        }
        return res.toArray(new int[res.size()][]);
    }
    ```

    **总结：**  
    先排序将L确定
    再确定最简单的不需要合并的情况 （右1 < 左2）  直接添加  
    最后需要合并的 取右边更大的一个  更改值

    ---
4. 二维数组---原地旋转矩阵  
    &emsp;&emsp;一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请将图像旋转 90 度。  
    ⭐不占用额外内存空间能否做到？

    ```Java
    // 1. 基本思路（占用了额外内存空间）
    public void rotate(int[][] matrix) {
            int n = matrix.length;
            
            // 使用新的二维数组来存储
            int[][] matrix2 = new int[n][n];
            for (int j = 0; j < n;j++) {
                for (int i = n - 1; i >= 0;i--) { 
                    // 0 -> 2; 1 -> 1; 2 -> 0;总结出 (n-1-i)
                    matrix2[j][n - 1 - i] = matrix[i][j];}}
            // 将旋转后的矩阵拷贝回原矩阵
            for (int i = 0; i < n; i++) {
                // 将matrix2 数组的第 i 行复制到 matrix 数组的第 i 行，复制的长度为 n
                System.arraycopy(matrix2[i], 0, matrix[i], 0, n);}
        }

    // 2. 翻转代替旋转
    public void rotate(int[][] matrix) {
            int n = matrix.length;
            ⭐// 主对角线翻转
            for (int j = 0; j < n;j++) {
                for (int i = j; i < n; i++) {
                    // 先保存原来的数据
                    int temp = matrix[j][i];
                    // 仅反转 i与j, [00,01,02] --> [00,10,20] 还需行内反转
                    matrix[j][i] = matrix[i][j];
                    // temp 再重新赋值给竖着的
                    matrix[i][j] = temp;}}
            ⭐// 水平翻转
            // 将每一行的元素进行反转,对称，只进行一半就可以
            for (int i = 0; i < n; i++) {
                for (int j = 0;j < n / 2; j++) {
                    int temp = matrix[i][j];
                    matrix[i][j] = matrix[i][n-1-j];
                    matrix[i][n-1-j] = temp;}}
        }

    // 3.改进---原地旋转
    public void rotate(int[][] matrix) {
            int n = matrix.length;
            // n为偶数，取 n/2 做起始点
            for (int i = 0; i < n / 2; ++i) {
                // n为奇数，取 (n+1)/2 做起始点
                for (int j = 0; j < (n + 1) / 2; ++j) {
                    // 5个公式完成闭环
                    int temp = matrix[i][j];
                    matrix[i][j] = matrix[n - j - 1][i];
                    matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                    matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                    matrix[j][n - i - 1] = temp;    }}
        }
    ```

    ![alt text](images/原地旋转.png)

    分块内部反转再移动到相应位置：  
    <img src="images/偶数.png" width="250"> ======== <img src="images/奇数.png" width="244">

5. 零矩阵  
    编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

    ```Java
    public void setZeroes(int[][] matrix) {
            int m = matrix.length, n = matrix[0].length;
            boolean[] row = new boolean[m];
            boolean[] col = new boolean[n];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (matrix[i][j] == 0) {
                        // 对这一行或者这一列 标记
                        row[i] = col[j] = true;
                    }}}
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    // 属于标记的行或列就 置为0
                    if (row[i] || col[j]) {
                        matrix[i][j] = 0;
                    }}}
        }
    ```

6. 对角线遍历  
<img src="images/对角线遍历.png" width="300">  

⭐m行就有m条, n列n条因为第1行算过了，就-1

- 共有m+n-1条对角线  对角线编号为i 属于（0, m+n-2）
  - i为偶数：从下往上遍历  
  - i为奇数：从上往下  

- 从下往上时：
  - 当 i < m 时, 该对角线遍历起点为 (i, 0)
  - 当 i >= m 时，起点为 (m-1, i-m+1)  
  &emsp;&emsp;⭐(m-1)即最后一行，(i-m+1)是 i 距离 m 即拥有元素最多的一条对角线的距离 + 1,因为m就在第1列
- 从上往下时：
  - 当 i < n 时, 起点为 (0, i)
  - 当 i >= n 时, 起点为 (i-n+1, n-1)

    ```Java
    // 第一种解法  常规
    public int[] findDiagonalOrder(int[][] mat) {
            int m = mat.length;
            int n = mat[0].length;
            int[] res = new int[m * n];
            // 存放在res的顺序
            int pos = 0;
            for (int i = 0; i < m + n - 1; i++) {
                // 条数为奇数，从上往下
                if (i % 2 == 1) {
                    int x = i < n ? 0 : i - n + 1;
                    int y = i < n ? i : n - 1;
                    while (x < m && y >= 0) {
                        res[pos] = mat[x][y];
                        pos++;
                        // 向左下继续遍历
                        x++;
                        y--;}} 
                else {
                    int x = i < m ? i : m - 1;
                    int y = i < m ? 0 : i - m + 1;
                    while (x >= 0 && y < n) {
                        res[pos] = mat[x][y];
                        pos++;
                        // 向右上
                        x--;
                        y++;}}       
            }
            return res;
        }
    // 第二种：根据 ⭐ (i = x + y) ,第 i条的 i就等于 该对角线上横纵坐标之和
    for (int i = 0, idx = 0; i < n + m - 1; i++) 
    {
        if (i % 2 == 0) //偶数对角线, 从下往上遍历
            for (int x = Math.min(i, m - 1); x >= Math.max(0, i - n + 1); x -- ) 
                res[idx++] = mat[x][i - x];
        else       //奇数对角线,从上往下遍历
            for (int x = Math.max(0, i - n + 1); x <= Math.min(i, m - 1); x ++ )
                res[idx++] = mat[x][i - x];
    }
    ```

#### 二、字符串

1. 比较字符串： == | equals | compareTo  

    ```Java
    // 定义 s1、s2、s3
    String s1 = "Hello World!";
    String s2 = s1;                 // 将 s1 的引用值赋给了 s2, 指向同一个对象
    String s3 = new String(s1);     // 重新创建了一个对象，在内存中地址不同，值内容相同

    // ① 使用 "==" 比较 (内存地址，是否指向同一对象)
    s1 == "Hello World";        // true
    s1 == s2;                   // true
    s1 == s3;                   // false⭐

    // ② 使用 "equals()" 方法比较 (仅比较值)
    s1.equals("Hello World");   // true
    s1.equals(s2);              // true
    s1.equals(s3);              // true

    // ③ 使用 "CompareTo()" 比较（两个字符串的字典顺序）
    s1.compareTo("Hello World") == 0);  // true
    s1.compareTo(s2) == 0);             // true
    s1.compareTo(s3) == 0);             // true
    ```

    总结：

    - ① "=="比较 **字符串** 比较的是其内存的地址值，  
    对于**基本数据类型**(int,char) 比较值是否相等。  
    - ② "equals()"比较，在Object类中  <u>默认也比较的是内存地址</u>，  
    但在许多类(String、Integer、Date)中重写了，只用来比较 值是否相同。  
    - ③ "CompareTo"比较 是字符串的字典顺序，相同为0，  
    a.CompareTo(b),若a在b前，返回负值，反之返回正值。  

2. 连接字符串  
    使用 **toCharArray** 转换为字符数组，字符串可变  
    如果经常连接字符串，使用 **StringBuilder** 数据类型

3. 最长公共前缀  

   - 横向扫描

   ```Java
   public String longestCommonPrefix(String[] strs) {
           if (strs == null || strs.length == 0) {
               return "";}
           String prefix = strs[0];
           int count = strs.length;
           for (int i = 1; i < count; i++) {
               prefix = longestCommonPrefix(prefix, strs[i]);
               if (prefix.length() == 0) {
                   break;}}
           return prefix;}

       public String longestCommonPrefix(String str1, String str2) {
           int length = Math.min(str1.length(), str2.length());
           int index = 0;
           while (index < length && str1.charAt(index) == str2.charAt(index)) {
               index++;
           }
           return str1.substring(0, index);}
   ```

   - 纵向扫描  

   ```Java
   class Solution {
       public String longestCommonPrefix(String[] strs) {
           // 先排除字符串数组为空的情况
        if (strs == null || strs.length == 0) {
            return "";}
        // 获取第一个字符串准备与后面的比较
        int length = strs[0].length();
        // 获取数组长度
        int count = strs.length;

        // 纵向查找action
        // 先取每个字符的第一个字符，若成功匹配则循环下一个字符
        for (int i=0; i < length;i++) {
            // 取到第一个字符串 索引为 i 的字符
            char c = strs[0].charAt(i);
            for (int j=1; j < count;j++) {
                // 先确定后面的字符串还有后余字符
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                   }}}
           return strs[0];}}
   ```

   - 分治法

   ```java
   class Solution {
       public String longestCommonPrefix(String[] strs) {
           if (strs == null || strs.length == 0) {
               return "";
           } else {
               return longestCommonPrefix(strs, 0, strs.length - 1);
           }
       }

       public String longestCommonPrefix(String[] strs, int start, int end) {
           if (start == end) {
               return strs[start];
           } else {
               int mid = (end - start) / 2 + start;
               String lcpLeft = longestCommonPrefix(strs, start, mid);
               String lcpRight = longestCommonPrefix(strs, mid + 1, end);
               return commonPrefix(lcpLeft, lcpRight);}}

       public String commonPrefix(String lcpLeft, String lcpRight) {
           int minLength = Math.min(lcpLeft.length(), lcpRight.length());       
           for (int i = 0; i < minLength; i++) {
               if (lcpLeft.charAt(i) != lcpRight.charAt(i)) {
                   return lcpLeft.substring(0, i);
               }}
           return lcpLeft.substring(0, minLength);}}
   ```

   - 二分查找法

   ```Java
   class Solution {
       public String longestCommonPrefix(String[] strs) {
           if (strs == null || strs.length == 0) {
               return "";
           }
           int minLength = Integer.MAX_VALUE;
           for (String str : strs) {
               minLength = Math.min(minLength, str.length());
           }
           int low = 0, high = minLength;
           while (low < high) {
               int mid = (high - low + 1) / 2 + low;
               if (isCommonPrefix(strs, mid)) {
                   low = mid;
               } else {
                   high = mid - 1;
               }}
           return strs[0].substring(0, low);}

       public boolean isCommonPrefix(String[] strs, int length) {
           String str0 = strs[0].substring(0, length);
           int count = strs.length;
           for (int i = 1; i < count; i++) {
               String str = strs[i];
               for (int j = 0; j < length; j++) {
                   if (str0.charAt(j) != str.charAt(j)) {
                       return false;
                   }}}
           return true;}}
   ```

4. ⭐最长回文子串  

    ```Java
    // ⭐1. 动态规划
    // 状态转移方程
    P(i,j)=P(i+1,j−1)∧(Si == Sj)

    public class Solution {

        public String longestPalindrome(String s) {
            int len = s.length();
            if (len < 2) {    return s;   }

            int maxLen = 1;
            int begin = 0;
            // dp[i][j] 表示 s[i..j] 是否是回文串
            boolean[][] dp = new boolean[len][len];
            // 初始化：所有长度为 1 的子串都是回文串
            // 先把可以简单判断为 true 的标记出来
            for (int i = 0; i < len; i++) {
                dp[i][i] = true;
            }

            char[] charArray = s.toCharArray();
            // 递推开始
            // 先枚举子串长度（长度为1或2的已经标记过了，L从2开始）
            for (int L = 2; L <= len; L++) {
                // 枚举左边界，左边界的上限设置可以宽松一些
                for (int i = 0; i < len; i++) {
                    // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                    int j = L + i - 1;
                    // 如果右边界越界，就可以退出当前循环
                    if (j >= len) {     break;    }

                    if (charArray[i] != charArray[j]) {
                        dp[i][j] = false;
                    } else {
                        // 已到达中心位置
                        if (j - i < 3) {
                            dp[i][j] = true;
                        } else {   
                            // 首尾相等且中间还要字串，则只要判断字段是否为回文即可 
                            dp[i][j] = dp[i + 1][j - 1];   
                        }}

                    // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                    if (dp[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        begin = i;
                    }}}
            return s.substring(begin, begin + maxLen);}}

    // 2. 中心扩展算法
    public String longestPalindrome(String s) {
            if (s == null || s.length() < 1) {
                return "";
            }
            int start = 0, end = 0;
            for (int i = 0; i < s.length(); i++) {
                int len1 = expandAroundCenter(s, i, i);
                int len2 = expandAroundCenter(s, i, i + 1);
                int len = Math.max(len1, len2);
                if (len > end - start) {
                    start = i - (len - 1) / 2;
                    end = i + len / 2;
                }}
            return s.substring(start, end + 1);
        }

        public int expandAroundCenter(String s, int left, int right) {
            while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
                --left;
                ++right;
            }
            return right - left - 1;
        }
    ```

5. 反转字符串里的单词

    ```java
    public String reverseWords(String s) {
            // 除去开头和末尾的空白字符
            s = s.trim();
            // 正则匹配连续的空白字符作为分隔符分割
            List<String> wordList = Arrays.asList(s.split("\\s+"));
            Collections.reverse(wordList);
            return String.join(" ", wordList);
        }
    ```

6. 双指针之反转字符串

    ```java
    // 我的傻子法
    class Solution {
        public void reverseString(char[] s) {
            int n = s.length;
            // 定义双指针
            int l = 0;
            int r = n-1;
            char temp;
            while(l<r) {
                temp = s[l];
                s[l] = s[r];
                s[r] = temp;
                l++;
                r--;
            }
            // 直接打印s的是s的地址，应该用String.valueOf()
            System.out.println(String.valueOf(s));
        }
    }

    // 优雅不耗时法
    class Solution {
        public void reverseString(char[] s) {
            int n = s.length;
            for (int left = 0, right = n - 1; left < right; ++left, --right) {
                char tmp = s[left];
                s[left] = s[right];
                s[right] = tmp;
            }
        }
    }
    ```

7. 